#!/usr/bin/env tsx
/**
 * GREP Agent: Feature Ideator (Claude-Powered)
 *
 * Analyzes the codebase and suggests new features by:
 * - Understanding existing functionality
 * - Identifying gaps and opportunities
 * - Proposing features aligned with the project vision
 * - Creating detailed feature proposals as issues
 */

import { Octokit } from '@octokit/rest'
import { askClaude } from './claude-client'
import { execSync } from 'child_process'
import * as fs from 'fs'
import * as path from 'path'

const IDEATOR_PROMPT = `You are a creative product designer and developer for GrepCoin, a Web3 arcade gaming platform.

Your mission: Generate innovative, implementable feature ideas that enhance the GrepCoin ecosystem.

Context about GrepCoin:
- 8 playable browser games with GREP token rewards
- GREP token with staking for multipliers and bonus plays
- Achievement system with unlockable badges
- Daily challenges and leaderboards
- Built on Base L2 blockchain
- Community via Discord

When generating features, consider:
1. Player engagement and retention
2. Token utility and value accrual
3. Community building
4. Technical feasibility
5. Uniqueness in the Web3 gaming space

For each feature idea, provide:
- **Title**: Catchy, descriptive name
- **Category**: Game, Token, Social, Technical, Community
- **Priority**: High/Medium/Low
- **Effort**: Small (1-3 days), Medium (1-2 weeks), Large (1+ month)
- **Description**: What it does and why it matters
- **User Story**: As a [user], I want [goal] so that [benefit]
- **Technical Approach**: High-level implementation notes
- **Success Metrics**: How to measure if it's working

Generate 3 diverse feature ideas - one quick win, one medium effort, and one ambitious moonshot.`

const CATEGORIES = {
  games: ['game mechanics', 'new games', 'multiplayer', 'tournaments'],
  token: ['staking', 'rewards', 'tokenomics', 'DeFi integration'],
  social: ['leaderboards', 'profiles', 'achievements', 'referrals'],
  technical: ['performance', 'security', 'infrastructure', 'analytics'],
  community: ['Discord', 'governance', 'events', 'content']
}

async function featureIdeator(): Promise<void> {
  const token = process.env.GITHUB_TOKEN
  const repo = process.env.GITHUB_REPOSITORY || ''
  const focusArea = process.env.FOCUS_AREA || 'all'

  if (!token || !repo) {
    console.error('Missing required environment variables')
    process.exit(1)
  }

  const [owner, repoName] = repo.split('/')
  const octokit = new Octokit({ auth: token })

  console.log('ğŸ’¡ GREP Feature Ideator starting...')
  console.log(`ğŸ¯ Focus area: ${focusArea}`)

  // Gather context about current state
  const codebaseContext = gatherCodebaseContext()
  const existingFeatures = await getExistingFeatureIssues(octokit, owner, repoName)

  // Build prompt with context
  const context = `
## Current Codebase State
${codebaseContext}

## Existing Feature Requests (to avoid duplicates)
${existingFeatures.length > 0 ? existingFeatures.map(f => `- ${f}`).join('\n') : 'No existing feature requests found'}

## Focus Area
${focusArea === 'all' ? 'Open to all categories' : `Focus on: ${focusArea}`}

Please generate 3 creative feature ideas that would enhance GrepCoin.
`

  console.log('ğŸ§  Generating feature ideas with Claude...')
  const response = await askClaude(IDEATOR_PROMPT, context, { maxTokens: 3000, temperature: 0.8 })

  // Parse and create issues
  const features = parseFeatureIdeas(response.content)

  console.log(`ğŸ“ Generated ${features.length} feature ideas`)

  // Create a summary issue with all ideas
  const summaryBody = `## ğŸ’¡ AI-Generated Feature Ideas

The GREP Feature Ideator has analyzed the codebase and generated the following feature suggestions:

${response.content}

---

### ğŸ—³ï¸ Community Input Needed

Please react to indicate your interest:
- ğŸ‘ Would use this feature
- ğŸš€ This should be high priority
- ğŸ¤” Need more details
- âŒ Not needed

### Next Steps
1. Discuss in comments
2. Maintainers will review feasibility
3. Approved features will be converted to tracked issues

---
<sub>ğŸ¤– Generated by GREP Feature Ideator | Run: ${new Date().toISOString()}</sub>`

  // Check if we should create new issue or comment on existing
  const { data: existingIssues } = await octokit.issues.listForRepo({
    owner,
    repo: repoName,
    labels: 'feature-ideas,automated',
    state: 'open'
  })

  if (existingIssues.length > 0) {
    // Comment on existing issue
    await octokit.issues.createComment({
      owner,
      repo: repoName,
      issue_number: existingIssues[0].number,
      body: `## ğŸ”„ New Feature Ideas Generated

${response.content}

---
<sub>Run: ${new Date().toISOString()}</sub>`
    })
    console.log(`ğŸ’¬ Added ideas to existing issue #${existingIssues[0].number}`)
  } else {
    // Create labels
    await ensureLabels(octokit, owner, repoName)

    // Create new issue
    const { data: newIssue } = await octokit.issues.create({
      owner,
      repo: repoName,
      title: 'ğŸ’¡ AI-Generated Feature Ideas',
      body: summaryBody,
      labels: ['feature-ideas', 'automated', 'discussion']
    })
    console.log(`ğŸ“‹ Created feature ideas issue #${newIssue.number}`)
  }

  console.log('âœ… Feature ideation complete')
}

function gatherCodebaseContext(): string {
  const context: string[] = []

  // Count games
  try {
    const gamesDir = path.join(process.cwd(), 'apps/web/src/app/games')
    if (fs.existsSync(gamesDir)) {
      const games = fs.readdirSync(gamesDir).filter(f =>
        fs.statSync(path.join(gamesDir, f)).isDirectory()
      )
      context.push(`**Games**: ${games.length} games (${games.join(', ')})`)
    }
  } catch { /* ignore */ }

  // Count components
  try {
    const componentsDir = path.join(process.cwd(), 'apps/web/src/components')
    if (fs.existsSync(componentsDir)) {
      const components = fs.readdirSync(componentsDir).filter(f => f.endsWith('.tsx'))
      context.push(`**Components**: ${components.length} React components`)
    }
  } catch { /* ignore */ }

  // Count API routes
  try {
    const result = execSync('find apps/web/src/app/api -name "route.ts" 2>/dev/null | wc -l', { encoding: 'utf8' })
    context.push(`**API Routes**: ${result.trim()} endpoints`)
  } catch { /* ignore */ }

  // Smart contracts
  try {
    const contractsDir = path.join(process.cwd(), 'packages/contracts/contracts')
    if (fs.existsSync(contractsDir)) {
      const contracts = fs.readdirSync(contractsDir).filter(f => f.endsWith('.sol'))
      context.push(`**Smart Contracts**: ${contracts.join(', ')}`)
    }
  } catch { /* ignore */ }

  // Check for specific features
  const features: string[] = []
  try {
    const webSrc = path.join(process.cwd(), 'apps/web/src')
    const srcContent = execSync(`grep -r "achievement\\|leaderboard\\|stake\\|referral" ${webSrc} 2>/dev/null | wc -l`, { encoding: 'utf8' })
    if (parseInt(srcContent) > 0) {
      features.push('Achievements', 'Leaderboards', 'Staking', 'Referrals')
    }
  } catch { /* ignore */ }

  if (features.length > 0) {
    context.push(`**Existing Features**: ${features.join(', ')}`)
  }

  return context.join('\n')
}

async function getExistingFeatureIssues(octokit: Octokit, owner: string, repo: string): Promise<string[]> {
  try {
    const { data: issues } = await octokit.issues.listForRepo({
      owner,
      repo,
      labels: 'enhancement',
      state: 'all',
      per_page: 20
    })
    return issues.map(i => i.title)
  } catch {
    return []
  }
}

function parseFeatureIdeas(content: string): Array<{ title: string; category: string }> {
  const features: Array<{ title: string; category: string }> = []

  // Simple parsing - look for numbered features or headers
  const lines = content.split('\n')
  let currentTitle = ''

  for (const line of lines) {
    if (line.match(/^#+\s*\d+\.|^#+\s*Feature|^\*\*Title\*\*:/i)) {
      currentTitle = line.replace(/^#+\s*\d+\.\s*|^#+\s*Feature\s*\d*:?\s*|^\*\*Title\*\*:\s*/i, '').trim()
    }
    if (currentTitle && line.includes('Category')) {
      const category = line.replace(/.*Category.*?:\s*/i, '').trim()
      features.push({ title: currentTitle, category })
      currentTitle = ''
    }
  }

  return features
}

async function ensureLabels(octokit: Octokit, owner: string, repo: string): Promise<void> {
  const labels = [
    { name: 'feature-ideas', color: '6F42C1', description: 'AI-generated feature suggestions' },
    { name: 'discussion', color: 'D4C5F9', description: 'Needs community discussion' }
  ]

  for (const label of labels) {
    try {
      await octokit.issues.createLabel({ owner, repo, ...label })
    } catch { /* Label exists */ }
  }
}

// Run
featureIdeator().catch((error) => {
  console.error('âŒ Feature ideator failed:', error)
  process.exit(1)
})
