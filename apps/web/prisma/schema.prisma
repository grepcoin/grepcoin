// GrepCoin Arcade Database Schema
// PostgreSQL on NeonDB

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Core user model - wallet-based authentication
model User {
  id                      String   @id @default(cuid())
  walletAddress           String   @unique
  username                String?  @unique
  avatar                  String?
  referralCode            String?  @unique // User's unique referral code
  notificationPreferences Json? // Push notification preferences
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  // Relations
  gameScores               GameScore[]
  achievements             UserAchievement[]
  stakes                   Stake[]
  dailyStats               DailyStats[]
  dailyRewards             DailyReward[]
  referralsMade            Referral[]              @relation("Referrer")
  referredBy               Referral?               @relation("Referee")
  friendsInitiated         Friendship[]            @relation("UserFriends")
  friendsReceived          Friendship[]            @relation("FriendOf")
  eventParticipations      EventParticipant[]
  battlePassProgress       BattlePassProgress[]
  tournamentParticipations TournamentParticipant[]
  sellerListings           MarketplaceListing[]    @relation("SellerListings")
  buyerListings            MarketplaceListing[]    @relation("BuyerListings")
  leaderboardRewards       LeaderboardReward[]
  emailSettings            EmailSettings?
  emailVerifications       EmailVerification[]
  emailQueue               EmailQueue[]
  auctionsSelling          Auction[]               @relation("AuctionSeller")
  auctionsWinning          Auction[]               @relation("AuctionHighestBidder")
  bids                     Bid[]
  inventoryItems           InventoryItem[]
  nftMints                 NFTMint[]
  pushSubscriptions        PushSubscription[]
}

// Game definitions
model Game {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String
  icon        String
  color       String
  minReward   Int
  maxReward   Int
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  scores     GameScore[]
  challenges DailyChallenge[]
}

// Game scores and sessions
model GameScore {
  id         String   @id @default(cuid())
  userId     String
  gameId     String
  score      Int
  grepEarned Int
  duration   Int // seconds
  streak     Int      @default(0)
  multiplier Float    @default(1)
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([gameId])
  @@index([createdAt(sort: Desc)])
  @@index([score(sort: Desc)])
}

// Achievement definitions
model Achievement {
  id          String  @id @default(cuid())
  slug        String  @unique
  name        String
  description String
  icon        String
  rarity      String // common, uncommon, rare, epic, legendary
  reward      Int
  type        String // score, streak, games, perfect, challenge
  target      Int?
  gameSlug    String? // null means global achievement

  users UserAchievement[]
}

// User's achievement progress and unlocks
model UserAchievement {
  id            String    @id @default(cuid())
  userId        String
  achievementId String
  progress      Int       @default(0)
  unlockedAt    DateTime?
  createdAt     DateTime  @default(now())

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
}

// Staking records (synced from blockchain)
model Stake {
  id          String    @id @default(cuid())
  userId      String
  amount      BigInt
  tier        String // flexible, bronze, silver, gold, diamond
  multiplier  Float     @default(1)
  lockedUntil DateTime?
  txHash      String?   @unique
  chainId     Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Daily challenges
model DailyChallenge {
  id         String   @id @default(cuid())
  gameId     String
  type       String // score, streak, speed, perfect
  target     Int
  reward     Int
  multiplier Float    @default(1)
  date       DateTime @db.Date

  game        Game                  @relation(fields: [gameId], references: [id], onDelete: Cascade)
  completions ChallengeCompletion[]

  @@unique([gameId, date])
  @@index([date])
}

// Challenge completions
model ChallengeCompletion {
  id            String   @id @default(cuid())
  challengeId   String
  walletAddress String
  completedAt   DateTime @default(now())

  challenge DailyChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  @@unique([challengeId, walletAddress])
}

// Daily stats per user (for rate limiting and tracking)
model DailyStats {
  id          String   @id @default(cuid())
  userId      String
  date        DateTime @db.Date
  grepEarned  Int      @default(0)
  gamesPlayed Int      @default(0)
  bestStreak  Int      @default(0)
  playsUsed   Int      @default(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([date])
}

// Global platform stats (cached for performance)
model GlobalStats {
  id               String   @id @default("global")
  totalPlayers     Int      @default(0)
  totalGrepEarned  BigInt   @default(0)
  totalGamesPlayed BigInt   @default(0)
  updatedAt        DateTime @updatedAt
}

// Live activity feed
model Activity {
  id        String   @id @default(cuid())
  type      String // score, achievement, reward, streak, levelup
  wallet    String
  username  String?
  game      String?
  value     Int?
  message   String
  icon      String
  createdAt DateTime @default(now())

  @@index([createdAt(sort: Desc)])
}

// Auth sessions (for SIWE)
model Session {
  id            String   @id @default(cuid())
  walletAddress String
  nonce         String   @unique
  expiresAt     DateTime
  createdAt     DateTime @default(now())

  @@index([walletAddress])
  @@index([expiresAt])
}

// Daily login rewards
model DailyReward {
  id        String   @id @default(cuid())
  userId    String
  day       Int // 1-7 streak day
  reward    Int
  claimedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, claimedAt])
}

// Referral tracking
model Referral {
  id         String   @id @default(cuid())
  referrerId String
  refereeId  String   @unique
  code       String   @unique
  rewardPaid Int      @default(0)
  maxReward  Int      @default(5000) // Max GREP earnable from this referral
  createdAt  DateTime @default(now())
  expiresAt  DateTime // 30 days from creation

  referrer User @relation("Referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referee  User @relation("Referee", fields: [refereeId], references: [id], onDelete: Cascade)

  @@index([referrerId])
  @@index([code])
}

// Airdrop campaigns and claims
model AirdropClaim {
  id            String    @id @default(cuid())
  walletAddress String
  amount        BigInt
  campaignId    String
  claimedAt     DateTime?
  txHash        String?
  merkleProof   String? // JSON array of proof elements

  @@unique([walletAddress, campaignId])
  @@index([campaignId])
}

// Fundraising backers
model Backer {
  id          String    @id @default(cuid())
  wallet      String?
  email       String?
  name        String?
  tier        String // early-bird, builder, partner, genesis
  amount      Int // Amount in USD
  currency    String    @default("USD") // USD, ETH, USDC
  txHash      String?   @unique
  status      String    @default("pending") // pending, confirmed, refunded
  message     String? // Optional message from backer
  anonymous   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  confirmedAt DateTime?

  @@index([tier])
  @@index([status])
  @@index([createdAt(sort: Desc)])
}

// Fundraising campaign stats (singleton)
model FundraiseStats {
  id          String   @id @default("campaign")
  totalRaised Int      @default(0) // Total USD raised
  backerCount Int      @default(0) // Number of backers
  goalAmount  Int      @default(100000) // Target goal in USD
  startDate   DateTime @default(now())
  endDate     DateTime
  isActive    Boolean  @default(true)
  updatedAt   DateTime @updatedAt
}

// Friendship system
model Friendship {
  id         String       @id @default(cuid())
  userId     String
  friendId   String
  status     FriendStatus @default(PENDING)
  createdAt  DateTime     @default(now())
  acceptedAt DateTime?

  user   User @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendOf", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
  @@index([status])
}

enum FriendStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

// Events system
model Event {
  id          String      @id @default(cuid())
  name        String
  description String
  type        EventType
  gameSlug    String?
  startTime   DateTime
  endTime     DateTime
  rewards     Json
  rules       Json
  status      EventStatus @default(SCHEDULED)
  createdAt   DateTime    @default(now())

  participants EventParticipant[]

  @@index([status])
  @@index([startTime])
  @@index([endTime])
}

model EventParticipant {
  id       String   @id @default(cuid())
  eventId  String
  userId   String
  score    Int      @default(0)
  joinedAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

enum EventType {
  DAILY
  WEEKEND
  SEASONAL
  FLASH
}

enum EventStatus {
  SCHEDULED
  ACTIVE
  ENDED
}

// Battle Pass System
model BattlePass {
  id         String   @id @default(cuid())
  season     Int      @unique
  name       String
  startDate  DateTime
  endDate    DateTime
  levels     Int      @default(50)
  xpPerLevel Int      @default(1000)
  createdAt  DateTime @default(now())

  rewards  BattlePassReward[]
  progress BattlePassProgress[]
}

model BattlePassReward {
  id           String     @id @default(cuid())
  battlePassId String
  level        Int
  tier         RewardTier
  type         RewardType
  value        Json

  battlePass BattlePass @relation(fields: [battlePassId], references: [id], onDelete: Cascade)

  @@unique([battlePassId, level, tier])
  @@index([battlePassId])
}

model BattlePassProgress {
  id            String   @id @default(cuid())
  battlePassId  String
  userId        String
  level         Int      @default(1)
  xp            Int      @default(0)
  isPremium     Boolean  @default(false)
  claimedLevels Int[]    @default([])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  battlePass BattlePass @relation(fields: [battlePassId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([battlePassId, userId])
  @@index([userId])
  @@index([battlePassId])
}

enum RewardTier {
  FREE
  PREMIUM
}

enum RewardType {
  GREP
  BADGE
  MULTIPLIER
  NFT
}

// Tournament System
model Tournament {
  id         String           @id @default(cuid())
  name       String
  gameSlug   String
  entryFee   Int              @default(0)
  prizePool  Int
  maxPlayers Int
  startTime  DateTime
  endTime    DateTime
  status     TournamentStatus @default(REGISTRATION)
  createdAt  DateTime         @default(now())

  participants TournamentParticipant[]

  @@index([status])
  @@index([startTime])
  @@index([gameSlug])
}

model TournamentParticipant {
  id           String   @id @default(cuid())
  tournamentId String
  userId       String
  score        Int      @default(0)
  rank         Int?
  joinedAt     DateTime @default(now())

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, userId])
  @@index([tournamentId])
  @@index([userId])
  @@index([score])
}

enum TournamentStatus {
  REGISTRATION
  ACTIVE
  COMPLETED
  CANCELLED
}

// Marketplace System
model MarketplaceListing {
  id         String        @id @default(cuid())
  sellerId   String
  itemId     String
  itemName   String
  itemType   String
  itemRarity String
  itemIcon   String
  price      Int
  currency   Currency      @default(GREP)
  status     ListingStatus @default(ACTIVE)
  listedAt   DateTime      @default(now())
  expiresAt  DateTime
  soldAt     DateTime?
  buyerId    String?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  seller User  @relation("SellerListings", fields: [sellerId], references: [id], onDelete: Cascade)
  buyer  User? @relation("BuyerListings", fields: [buyerId], references: [id], onDelete: SetNull)

  @@index([sellerId])
  @@index([buyerId])
  @@index([status])
  @@index([currency])
  @@index([price])
  @@index([itemType])
  @@index([createdAt(sort: Desc)])
}

enum Currency {
  GREP
  ETH
}

enum ListingStatus {
  ACTIVE
  SOLD
  CANCELLED
  EXPIRED
}

// Leaderboard Rewards Distribution
model LeaderboardDistribution {
  id        String             @id @default(cuid())
  period    DistributionPeriod
  startDate DateTime
  endDate   DateTime
  status    DistributionStatus @default(SCHEDULED)
  totalPool Int
  createdAt DateTime           @default(now())

  rewards LeaderboardReward[]

  @@index([period])
  @@index([status])
  @@index([endDate])
}

model LeaderboardReward {
  id             String       @id @default(cuid())
  distributionId String
  userId         String
  rank           Int
  grepAmount     Int
  badgeId        String?
  multiplier     Float?
  status         RewardStatus @default(PENDING)
  claimedAt      DateTime?
  createdAt      DateTime     @default(now())

  distribution LeaderboardDistribution @relation(fields: [distributionId], references: [id], onDelete: Cascade)
  user         User                    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([distributionId, userId])
  @@index([userId])
  @@index([status])
  @@index([distributionId])
}

enum DistributionPeriod {
  WEEKLY
  MONTHLY
}

enum DistributionStatus {
  SCHEDULED
  ACTIVE
  DISTRIBUTING
  COMPLETED
}

enum RewardStatus {
  PENDING
  CLAIMED
  EXPIRED
}

// Email Notification System
model EmailSettings {
  id       String  @id @default(cuid())
  userId   String  @unique
  email    String?
  verified Boolean @default(false)

  // Email preferences - toggles per type
  welcomeEnabled         Boolean @default(true)
  weeklyDigestEnabled    Boolean @default(true)
  achievementEnabled     Boolean @default(true)
  rewardClaimEnabled     Boolean @default(true)
  tournamentStartEnabled Boolean @default(true)
  friendRequestEnabled   Boolean @default(true)

  // Global unsubscribe
  unsubscribedAll Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
}

model EmailVerification {
  id        String   @id @default(cuid())
  userId    String
  email     String
  token     String   @unique
  expiresAt DateTime
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model EmailQueue {
  id          String      @id @default(cuid())
  userId      String?
  email       String
  emailType   EmailType
  subject     String
  htmlContent String
  data        Json?
  status      EmailStatus @default(PENDING)
  attempts    Int         @default(0)
  lastError   String?
  sentAt      DateTime?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([emailType])
  @@index([createdAt])
}

enum EmailType {
  WELCOME
  WEEKLY_DIGEST
  ACHIEVEMENT
  REWARD_CLAIM
  TOURNAMENT_START
  FRIEND_REQUEST
}

enum EmailStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}

// Auction System
model Auction {
  id              String        @id @default(cuid())
  sellerId        String
  itemId          String
  itemName        String
  itemType        String
  itemRarity      String
  itemIcon        String
  startingPrice   Int
  currentBid      Int           @default(0)
  highestBidderId String?
  startTime       DateTime
  endTime         DateTime
  status          AuctionStatus @default(PENDING)
  minIncrement    Int           @default(100)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  seller        User  @relation("AuctionSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  highestBidder User? @relation("AuctionHighestBidder", fields: [highestBidderId], references: [id], onDelete: SetNull)
  bids          Bid[]

  @@index([sellerId])
  @@index([highestBidderId])
  @@index([status])
  @@index([endTime])
  @@index([currentBid])
  @@index([createdAt(sort: Desc)])
}

model Bid {
  id        String   @id @default(cuid())
  auctionId String
  bidderId  String
  amount    Int
  timestamp DateTime @default(now())
  isWinning Boolean  @default(false)

  auction Auction @relation(fields: [auctionId], references: [id], onDelete: Cascade)
  bidder  User    @relation(fields: [bidderId], references: [id], onDelete: Cascade)

  @@index([auctionId])
  @@index([bidderId])
  @@index([timestamp(sort: Desc)])
}

enum AuctionStatus {
  PENDING
  ACTIVE
  ENDED
  CANCELLED
}

// Inventory system with NFT support
model InventoryItem {
  id          String   @id @default(cuid())
  userId      String
  itemId      String // Item definition ID (avatar-crown, boost-2x, etc)
  quantity    Int      @default(1)
  equipped    Boolean  @default(false)
  tokenId     Int? // NFT token ID if minted on-chain
  isMinted    Boolean  @default(false) // Whether this item is minted as NFT
  metadataURI String? // IPFS URI for NFT metadata
  acquiredAt  DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([itemId])
  @@index([tokenId])
  @@index([isMinted])
}

// Track NFT minting transactions
model NFTMint {
  id              String    @id @default(cuid())
  userId          String
  inventoryId     String    @unique // Link to InventoryItem
  tokenId         Int
  contractAddress String
  chainId         Int
  txHash          String?
  metadataURI     String
  status          String    @default("pending") // pending, confirmed, failed
  createdAt       DateTime  @default(now())
  confirmedAt     DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenId])
  @@index([status])
}

// Push Notification Subscriptions
model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String   @unique
  p256dh    String // Public key for encryption
  auth      String // Authentication secret
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([endpoint])
}
